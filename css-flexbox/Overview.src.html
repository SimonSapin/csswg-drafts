<h1>CSS Flexible Box Layout Module Level 1</h1>

<pre class='metadata'>
Shortname: css-flexbox
Level: 1
Status: ED
Group: csswg
ED: http://dev.w3.org/csswg/css-flexbox/
TR: http://www.w3.org/TR/css3-flexbox/
Previous Version: http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/
Previous Version: http://www.w3.org/TR/2012/WD-css3-flexbox-20120612/
Previous Version: http://www.w3.org/TR/2012/WD-css3-flexbox-20120322/
Previous Version: http://www.w3.org/TR/2011/WD-css3-flexbox-20111129/
Previous Version: http://www.w3.org/TR/2011/WD-css3-flexbox-20110322/
Previous Version: http://www.w3.org/TR/2009/WD-css3-flexbox-20090723/
Abstract: The specification describes a CSS box model optimized for user interface design. In the flex layout model, the children of a flex container can be laid out in any direction, and can "flex" their sizes, either growing to fill unused space or shrinking to avoid overflowing the parent. Both horizontal and vertical alignment of the children can be easily manipulated. Nesting of these boxes (horizontal inside vertical, or vertical inside horizontal) can be used to build layouts in two dimensions.
Editor: Tab Atkins Jr., Google, http://xanthir.com/contact/
Editor: fantasai, Mozilla, http://fantasai.inkedblade.net/contact
Editor: Rossen Atanassov, Microsoft, ratan@microsoft.com
Former Editor: Alex Mogilevsky, Microsoft Corporation, alexmog@microsoft.com
Former Editor: L. David Baron, Mozilla Corporation, dbaron@dbaron.org
Former Editor: Neil Deakin, Mozilla Corporation, enndeakin@gmail.com
Former Editor: Ian Hickson, formerly of Opera Software, ian@hixie.ch
Former Editor: David Hyatt, formerly of Netscape Corporation, hyatt@apple.com
Test Suite: http://test.csswg.org/suites/css3-flexbox/nightly-unstable/
!Issues List: Tracked in spec, and in <a href="https://www.w3.org/Bugs/Public/buglist.cgi?product=CSS&component=Flexbox&resolution=---">Bugzilla</a>
Ignored Terms: column-*, auto
Link Defaults: css21 (property) margin/min-width/min-height/max-width/max-height, css-break-3 (property) break-after
</pre>
<style>
code.one-line { white-space: pre; }
.code-and-figure {
	display: table;
	margin: 0 auto;
	border-spacing: 1em;
}
.code-and-figure > div {
	display: table-cell;
	vertical-align: middle;
}
:not(code) var { font-style: normal; color: #005A9C; }

a > i { font-style: normal; }

ol[start="0"] { counter-reset: list -1; }
ol[start="0"],
ol.continue { list-style: none; }
ol[start="0"] > li,
ol.continue > li { position: relative; counter-increment: list; }
ol[start="0"] > li::before,
ol.continue > li::before { content: counter(list) "."; position: absolute; left: -4.5em; width: 4em; text-align: right; }
.compact, .compact li {
  margin-top: 0;
  margin-bottom: 0;
}

/* Overview catalog example */
#overview-example {
	display:table;
	margin: 0 auto 1em;
	border-spacing: .5em 0;
	min-width: 672px;
}
#overview-example > .col {
	display: table-column;
	background: hsl(60,100%,90%);
}
#overview-example > .desc {
	display: table-cell;
	vertical-align: top;
	width: 300px;
	padding: 1em 1em 0;
	text-align: left;
	border: thick solid hsl(60,80%,50%);
	border-radius: 1em 1em 0 0;
	border-bottom: none;
}
#overview-example > .desc > img {
	margin: 0 auto;
	display: block;
}
#overview-example > .desc > h1 {
	background: transparent;
}
#overview-example > .buttons {
	display: table-row;
}
#overview-example > .buttons > div {
	display: table-cell;
	border: thick solid hsl(60,80%,50%);
	border-radius: 0 0 1em 1em;
	border-top: none;
	text-align: center;
}
#overview-example button {
	background-color: hsl(120,100%,40%);
	border: medium inset hsl(120,70%,40%);
	border-radius: 1em;
	padding: .5em;
	font-weight: bold;
	color: white;
	font-size: 1.6em;
	cursor: pointer;
	width: 90%;
	margin: 1em auto;
}

/* Visibility: Collapse example */
#visibility-collapse-example {
	display: table;
	width: 100%;
	box-shadow: 3px 3px 10px #333;
}
#visibility-collapse-example > article,
#visibility-collapse-example > nav {
	display: table-cell;
}
#visibility-collapse-example > article {
	width: 100%;
	background: white;
}
#visibility-collapse-example ul,
#visibility-collapse-example li {
	list-style: none;
	margin: 0;
	padding: 0;
}
#visibility-collapse-example > nav > ul {
	background: #444;
	border-radius: 0.5em;
	padding: 0.075em;
}
#visibility-collapse-example li {
	padding: 0 0.5em;
	background: #ddd;
	color: black;
	border-radius: 0.40em;
	border: #444 solid 0.075em;
}
#visibility-collapse-example li li {
	background: #444;
	color: white;
	margin: 0 -0.5em;
	border-radius: 0;
}
#visibility-collapse-example li li:first-child {
	border-radius: 0.375em 0.375em 0 0;
}
#visibility-collapse-example a {
	background: transparent;
	color: inherit;
}
#visibility-collapse-example > nav > ul > li:target,
#visibility-collapse-example > nav > ul > li:hover {
	background: #888;
	color: white;
}
#visibility-collapse-example > nav > ul > li:not(:target):not(:hover) > ul {
	height: 0;
	overflow: hidden;
}

#auto-bar {
	overflow: hidden;
	padding: .25em 1em;
	background: #ddd;
	list-style: none;
	margin: 0;
	border-radius: .3em;
}
#auto-bar > li {
	float: left;
	color: black;
	margin: 0;
}
#auto-bar > li:first-child:after,
#auto-bar > li:first-child + li:after {
	content: " |  ";
	white-space: pre;
}
#auto-bar > li > a {
	display: inline-block;
	padding: 0 .25em;
	border-radius: .3em;
}
#auto-bar > li > a:not(:hover):not(:focus) {
	text-decoration: none;
}
#auto-bar > li > a:hover {
	color: #ddd;
	background: #444;
}
#auto-bar > #login { float: right; }


.cross-auto-figure > div {
	margin: 0 auto;
	width: 70px;
	background: #888;
	padding: 0 .5em;
	border-radius: 1em;
	border: 1px solid transparent;
}
.cross-auto-figure > div > div {
	border-spacing: 0;
	display: table;
	background: #ddd;
	color: black;
	text-align: center;
	margin: .5em auto;
	padding: .5em;
	border-radius: .5em;
}

.axis { color: hsl(  0,80%,40%); }
.side { color: hsl(240,80%,50%); }
.size { color: hsl(120,80%,30%); }
</style>

<h2 id="intro">
Introduction</h2>

	<p><em>This section is not normative.</em>

	<p>
		CSS 2.1 defined four layout modes &mdash; algorithms which determine
		the size and position of boxes based on their relationships
		with their sibling and ancestor boxes:

	<ul class="compact">
		<li>block layout, designed for laying out documents
		<li>inline layout, designed for laying out text
		<li>table layout, designed for laying out 2D data in a tabular format
		<li>positioned layout, designed for very explicit positioning without much regard for other elements in the document
	</ul>

	<p>
		This module introduces a new layout mode, <dfn export>flex layout</dfn>,
		which is designed for laying out more complex applications and webpages.

<h3 id="overview">
Overview</h3>
	<p><em>This section is not normative.</em>

	<p>
		Flex layout is superficially similar to block layout.
		It lacks many of the more complex text- or document-centric properties
		that can be used in block layout, such as
		<a href="http://www.w3.org/TR/CSS21/visuren.html#floats">floats</a> and
		<a href="http://www.w3.org/TR/css3-multicol/">columns</a>.
		In return it gains simple and powerful tools
		for distributing space and aligning content
		in ways that webapps and complex web pages often need.
		The contents of a flex container:
	<ul>
		<li>
			can be laid out in any <a href="#flex-direction-property">flow direction</a>
			(leftwards, rightwards, downwards, or even upwards!)
		<li>
			can have their display order <a href="#flex-flow-row-reverse">reversed</a> or
			<a href="#order-property">rearranged</a> at the style layer
			(i.e., visual order can be independent of source and speech order)
		<li>
			can be laid out linearly along a single (<i title="main axis">main</i>) axis or
			<a href="#flex-wrap-property">wrapped</a> into multiple lines along a secondary (<i title="cross axis">cross</i>) axis
		<li>
			can <a href="#flexibility">&ldquo;flex&rdquo; their sizes</a>
			to respond to the available space
		<li>
			can be <a href="#alignment">aligned</a> with respect to their container or each other
		<li>
			can be dynamically <a href="#visibility-collapse">collapsed</a> or uncollapsed
			along the <i>main axis</i> while preserving the container's <i>cross size</i>
	</ul>

	<div class='example'>
		<p>
			Here's an example of a catalog where each item has a title, an photo, a description, and a purchase button.
			The designer's intention is that each entry has the same overall size,
			that the photo be above the text,
			and that the purchase buttons aligned at the bottom, regardless of the length of the item's description.
			Flex layout makes many aspects of this design easy:

		<ul>
			<li>
				The catalog uses flex layout to lay out rows of items horizontally,
				and to ensure that items within a row are all equal-height.
				Each entry is then itself a column flex container,
				laying out its contents vertically.

			<li>
				Within each entry, the source document content is ordered logically
				with the title first, followed by the description and the photo.
				This provides a sensible ordering for speech rendering and in non-CSS browsers.
				For a more compelling visual presentation, however,
				'order' is used to pull the image up from later in the content to the top,
				and 'align-self' is used to center it horizontally.

			<li>
				An <a href="#auto-margins"><span class=css>auto</span> margin</a> above the purchase button
				forces it to the bottom within each entry box,
				regardless of the height of that item's description.
		</ul>

		<pre>
&lt;style>
#deals {
	display: flex;        /* Flex layout so items <a href="#align-self" title="Flex items stretch by default.">have equal height</a>  */
	flex-flow: row wrap;  /* <a href="http://dev.w3.org/csswg/css3-flexbox/#flex-flow-property">Allow items to wrap into multiple lines</a> */
}
.sale-item {
	display: flex;        /* Lay out each item using flex layout */
	flex-flow: column;    /* <a href="#flex-flow-property">Lay out item's contents vertically</a>  */
}
.sale-item > img {
	order: -1;            /* <a href="#order-property">Shift image before other content (in visual order)</a> */
	align-self: center;   /* <a href="#align-self">Center the image cross-wise (horizontally)</a>         */
}
.sale-item > button {
	margin-top: auto;     /* <a href="#auto-margins">Auto top margin pushes button to bottom</a> */
}
&lt;/style></pre>
<pre>
&lt;section id='deals'>
  &lt;section class='sale-item'>
    &lt;h1>Computer Starter Kit&lt;/h1>
    &lt;p>This is the best computer money can buy, if you don't have much money.
    &lt;ul>
      &lt;li>Computer
      &lt;li>Monitor
      &lt;li>Keyboard
      &lt;li>Mouse
    &lt;/ul>
    &lt;img src='images/computer.jpg'
         alt='You get: a white computer with matching peripherals.'>
    &lt;button>BUY NOW&lt;/button>
  &lt;/section>
  &lt;section class='sale-item'>
    &hellip;
  &lt;/section>
  &hellip;
&lt;/section></pre>
		<figure>
			<div id="overview-example">
				<div class="col"></div>
				<div class="col"></div>
				<div class="desc">
					<img src="images/computer.jpg" alt='You get: a white computer with matching keyboard and monitor.'>
					<h1 style="font-size: 1.4em;">Computer Starter Kit</h1>
					<p>
						This is the best computer money can buy,
						if you don't have much money.
					<ul>
						<li>Computer
						<li>Monitor
						<li>Keyboard
						<li>Mouse
					</ul>
				</div>
				<div class="desc">
					<img src="images/printer.png" alt='You get: beautiful ASCII art.'>
					<h1 style="font-size: 1.4em;">Printer</h1>
					<p>
						Only capable of printing
						ASCII art.
					<ul>
						<li>Paper and ink not included.
					</ul>
				</div>
				<div class="buttons">
					<div><button>BUY NOW</button></div>
					<div><button>BUY NOW</button></div>
				</div>
			</div>
			<figcaption>
				An example rendering of the code above.
			</figcaption>
		</figure>
	</div>

<h3 id="placement">
Module interactions</h3>

	<p>
		This module extends the definition of the 'display' property [[!CSS21]],
		adding a new block-level and a new inline-level display type,
		and defining a new type of formatting context
		along with properties to control its layout.
		None of the properties defined in this module apply to the ''::first-line'' or ''::first-letter'' pseudo-elements.

<h3 id="values">
Values</h3>

	<p>
		This specification follows the <a href="http://www.w3.org/TR/CSS21/about.html#property-defs">CSS property definition conventions</a> from [[!CSS21]].
		Value types not defined in this specification are defined in CSS Level 2 Revision 1 [[!CSS21]].
		Other CSS modules may expand the definitions of these value types:
		for example [[CSS3VAL]], when combined with this module,
		expands the definition of the <var>&lt;length&gt;</var> value type as used in this specification.

	<p>In addition to the property-specific values listed in their definitions, all properties defined in this specification also accept the <a href="http://www.w3.org/TR/CSS21/cascade.html#value-def-inherit">''inherit''</a> keyword as their property value. For readability it has not been repeated explicitly.

<h2 id='box-model'>
Flex Layout Box Model and Terminology</h2>

	<p>
		An element with ''display:flex'' or ''display:inline-flex'' is a <i>flex container</i>.
		Children of a flex container are called <i>flex items</i> and are laid out using the flex layout model.

	<p>
		Unlike block and inline layout,
		whose layout calculations are biased to the <a href="http://www.w3.org/TR/css3-writing-modes/#abstract-box">block and inline flow directions</a>,
		flex layout is biased to the <dfn title="flex direction">flex directions</dfn>.
		To make it easier to talk about flex layout,
		this section defines a set of flex flow&ndash;relative terms.
		The 'flex-flow' value determines how these terms map
		to physical directions (top/right/bottom/left),
		axes (vertical/horizontal), and sizes (width/height).

	<figure>
		<img src='images/flex-direction-terms.svg' width=665 height=277 alt>
		<figcaption>
			An illustration of the various directions and sizing terms as applied to a ''row'' flex container.
		</figcaption>
	</figure>

	<dl id="main" export>
		<dt class='axis'>main axis
		<dt class='axis'>main dimension
		<dd>
			The <dfn title="main axis|main-axis">main axis</dfn> of a flex container is the primary axis along which <i>flex items</i> are laid out.
			It extends in the <dfn>main dimension</dfn>.

		<dt class='side'>main-start
		<dt class='side'>main-end
		<dd>
			The <i>flex items</i> are placed within the container
			starting on the <dfn>main-start</dfn> side
			and going toward the <dfn>main-end</dfn> side.

		<dt class='size'>main size
		<dt class='size'>main size property
		<dd>
			A <i>flex item</i>&apos;s width or height,
			whichever is in the <i>main dimension</i>,
			is the item's <dfn>main size</dfn>.
			The <i>flex item</i>&apos;s <dfn>main size property</dfn> is
			either the 'width' or 'height' property,
			whichever is in the <i>main dimension</i>.
	</dl>

	<dl id="cross" export>
		<dt class='axis'>cross axis
		<dt class='axis'>cross dimension
		<dd>
			The axis perpendicular to the <i>main axis</i> is called the <dfn title="cross axis|cross-axis">cross axis</dfn>.
			It extends in the <dfn>cross dimension</dfn>.

		<dt class='side'>cross-start
		<dt class='side'>cross-end
		<dd>
			<i>Flex lines</i> are filled with items and placed into the container
			starting on the <dfn>cross-start</dfn> side of the flex container
			and going toward the <dfn>cross-end</dfn> side.

		<dt class='size'>cross size
		<dt class='size'>cross size property
		<dd>
			The width or height of a <i>flex item</i>,
			whichever is in the <i>cross dimension</i>,
			is the item's <dfn>cross size</dfn>.
			The <dfn>cross size property</dfn> is
			whichever of 'width' or 'height' that is in the <i>cross dimension</i>.
	</dl>

<h2 id='flex-containers'>
Flex Containers: the <a href="#display-flex">''flex''</a> and <a href="#display-inline-flex">''inline-flex''</a> 'display' values</h2>

	<pre class="propdef">
	Name: display
	New values: flex | inline-flex
	</pre>

	<dl dfn-type=value dfn-for=display>
		<dt><dfn>flex</dfn>
		<dd>
			This value causes an element to generate a <a href="http://www.w3.org/TR/CSS2/visuren.html#x5">block-level</a> <i>flex container</i> box.

		<dt><dfn>inline-flex</dfn>
		<dd>
			This value causes an element to generate an <a href="http://www.w3.org/TR/CSS2/visuren.html#x11">inline-level</a> <i>flex container</i> box.
	</dl>

	<p>
		A <dfn export>flex container</dfn> establishes a new <dfn export>flex formatting context</dfn> for its contents.
		This is the same as establishing a block formatting context,
		except that flex layout is used instead of block layout:
		floats do not intrude into the flex container,
		and the flex container's margins do not collapse with the margins of its contents.
		<i>Flex containers</i> form a containing block for their contents
		<a href="http://www.w3.org/TR/CSS21/visudet.html#containing-block-details">exactly like block containers do</a>. [[!CSS21]]
		The 'overflow' property applies to <i>flex containers</i>.


	<p>
		Flex containers are not <a href="http://www.w3.org/TR/CSS21/visuren.html#block-container-box">block containers</a>,
		and so some properties that were designed with the assumption of block layout don't apply in the context of flex layout.
		In particular:

	<ul>
		<li>
			all of the 'column-*' properties in the Multicol module [[CSS3COL]] have no effect on a flex container.

		<li>
			'float' and 'clear' have no effect on a <i>flex item</i>.
			(However, the 'float' property still affects the computed value of 'display' on children of a flex container,
			as this occurs <em title=''>before</em> <i>flex items</i> are determined.)

		<li>
			'vertical-align' has no effect on a flex item.

		<li>
			the ''::first-line'' and ''::first-letter'' pseudo-elements do not apply to <i>flex containers</i>.
	</ul>

	<p>
		If an element's specified 'display' is ''inline-flex''
		and the element is floated or absolutely positioned,
		the computed value of 'display' is <a href="#display-flex">''flex''</a>.
		The table in <a href="http://www.w3.org/TR/CSS2/visuren.html#dis-pos-flo">CSS 2.1 Chapter 9.7</a> is thus amended
		to contain an additional row,
		with ''inline-flex'' in the "Specified Value" column
		and <a href="#display-flex">''flex''</a> in the "Computed Value" column.

<h2 id='flex-items'>
Flex Items</h2>

	<p>
		The contents of a <i>flex container</i> consists of zero or more <dfn export title="flex item" id="flex-item">flex items</dfn>:
		each in-flow child of a <i>flex container</i>
		becomes a <i>flex item</i>,
		and each contiguous run of text that is directly contained inside a <i>flex container</i>
		is wrapped in an anonymous <i>flex item</i>.
		However, an anonymous flex item that contains only
		<a href="http://www.w3.org/TR/CSS21/text.html#white-space-prop">white space</a>
		is not rendered, as if it were ''display:none''.

	<p class="note">
		Authors reading this spec may want to
		<a href="#item-margins">skip past these box-generation details</a>.

	<p>
		A <i>flex item</i> establishes a new formatting context for its contents.
		The type of this formatting context is determined by its 'display' value, as usual.
		The computed 'display' of a <i>flex item</i>
		is determined by applying the table in
		<a href="http://www.w3.org/TR/CSS2/visuren.html#dis-pos-flo">CSS 2.1 Chapter 9.7</a>
		(except that internal table elements are instead handled by anonymous box fixup, see below).
		However, flex items are flex-level boxes, not block-level boxes:
		they participate in their container's flex formatting context,
		not in a block formatting context.

	<p class='note'>
		The 'display' computation on flex items as defined here
		is expected to be superseded by a future specification
		that defines a new 'display' value specific to flex items.

	<div class="example">
		<p>Examples of flex items:
		<pre>
&lt;div style="display:flex">

    &lt;!-- flex item: block child -->
    &lt;div id="item1">block&lt;/div>

    &lt;!-- flex item: floated element; floating is ignored -->
    &lt;div id="item2" style="float: left;">float&lt;/div>

    &lt;!-- flex item: anonymous block box around inline content -->
    anonymous item 3

    &lt;!-- flex item: inline child -->
    &lt;span>
        item 4
        &lt;!-- flex items do not split around blocks -->
        &lt;div id=not-an-item>item 4&lt;/div>
        item 4
    &lt;/span>
&lt;/div></pre>
	</div>

	<p>
		Some values of 'display' trigger the generation of anonymous boxes.
		For example, a misparented ''table-cell'' child is fixed up
		by <a href="http://www.w3.org/TR/CSS21/tables.html#anonymous-boxes">generating anonymous ''table'' and ''table-row'' elements</a> around it. [[!CSS21]]
		This fixup must occur <em>before</em> a flex container's children are promoted to <i>flex items</i>.
		For example, given two contiguous child elements with ''display:table-cell'',
		an anonymous table wrapper box around them becomes the <i>flex item</i>.

	<p class='note'>
		Future display types may generate anonymous containers (e.g. ruby) or otherwise mangle the box tree (e.g. run-ins).
		It is intended that flex item determination run after these operations.

	<p id="table-items">
		On a flex item with ''display: table'', the table wrapper box becomes the <i>flex item</i>,
		and the 'order' and 'align-self' properties apply to it.
		The contents of any caption boxes contribute to the calculation of
		the table wrapper box's min-content and max-content sizes.
		However, like 'width' and 'height', the 'flex' longhands apply to the table box as follows:
		the <i>flex item</i>&apos;s final size is calculated
		by performing layout as if the distance between
		the table wrapper box's edges and the table box's content edges
		were all part of the table box's border+padding area,
		and the table box were the <i>flex item</i>.

<h3 id='abspos-items'>
Absolutely-Positioned Flex Children</h3>

	An absolutely-positioned child element of a <i>flex container</i> does not participate in flex layout
	beyond the <a href="#algo-flex-order">reordering step</a>.

	Its static position is calculated by first doing full flex layout without the absolutely-positioned elements,
	then positioning each absolutely-positioned child as if it were the sole <a>flex item</a>
	in the <a>flex container</a>,
	assuming it was a fixed size box of its used size.

	<div class='example'>
		For example, by default, the static position of an absolutely positioned element aligns it to the main-start/cross-start corner,
		corresponding to the default values of 'justify-self' and 'align-self'.
		Setting ''justify-self:center'', however,
		would center it in the main axis.
	</div>

<h3 id='item-margins'>
Flex Item Margins and Paddings</h3>

	<p>
		The margins of adjacent <i>flex items</i> do not collapse.
		Auto margins absorb extra space in the corresponding dimension and can be used for alignment
		and to push adjacent flex items apart;
		see <a href="#auto-margins">Aligning with <span class=css>auto</span> margins</a>.

	<p>
		Percentage margins and paddings on <i>flex items</i> are always resolved against their respective dimensions;
		unlike blocks, they do not always resolve against the inline dimension of their containing block.

<h3 id='painting'>
Flex Item Z-Ordering</h3>

	<p>
		<i>Flex items</i> paint exactly the same as inline blocks [[!CSS21]],
		except that 'order'-modified document order is used in place of raw document order,
		and <a href="http://www.w3.org/TR/CSS21/visuren.html#propdef-z-index">'z-index'</a>
		values other than <a value for=z-index>auto</a> create a stacking context
		even if 'position' is ''static''.

	<p class="note">
		Note: Descendants that are positioned outside a flex item still participate
		in any stacking context established by the flex item.

<h3 id='visibility-collapse'>
Collapsed Items</h3>

	<p>
		Specifying ''visibility:collapse'' on a flex item
		causes it to become a <dfn title="collapsed flex item|collapsed">collapsed flex item</dfn>,
		producing an effect similar to ''visibility:collapse'' on a table-row or table-column:
		the collapsed element is removed from rendering entirely,
		but leaves behind a "strut" that keeps the flex line's cross-size stable.
		Thus, if a flex container has only one flex line,
		dynamically collapsing or uncollapsing items
		is guaranteed to have no effect on the flex container's <i>cross size</i>
		and won't cause the rest of the page's layout to "wobble".
		Flex line wrapping <em>is</em> re-done after collapsing, however,
		so the cross-size of a flex container with multiple lines might or might not change.

	<p>
		Though collapsed flex items aren't rendered,
		they do appear in the <a href="http://www.w3.org/TR/CSS21/intro.html#formatting-structure">formatting structure</a>.
		Therefore, unlike on ''display:none'' items [[!CSS21]],
		effects that depend on an element appearing in the formatting structure
		(like incrementing counters or running animations and transitions)
		still operate on collapsed items.

	<div class="example">
		<p>In the following example,
		a sidebar is sized to fit its content.
		''visibility: collapse'' is used to dynamically hide parts of a navigation sidebar
		without affecting its width, even though the widest item (&ldquo;Architecture&rdquo;)
		is in a collapsed section.

		<figure>
			<figcaption>Sample rendering for example code below</figcaption>
			<div id="visibility-collapse-example">
			<!-- No, don't look at this source code, look at the other source code. -->
			  <nav>
			    <ul>
			      <li id="nav-about"><a href="#nav-about">About</a>
			        <ul>
			          <li><a href="#">History</a>
			          <li><a href="#">Mission</a>
			          <li><a href="#">People</a>
			        </ul>
			      <li id="nav-projects"><a href="#nav-projects">Projects</a>
			        <ul>
			          <li><a href="#">Art</a>
			          <li><a href="#">Architecture</a>
			          <li><a href="#">Music</a>
			        </ul>
			      <li id="nav-interact"><a href="#nav-interact">Interact</a>
			        <ul>
			          <li><a href="#">Blog</a>
			          <li><a href="#">Forums</a>
			          <li><a href="#">Events</a>
			        </ul>
			    </ul>
			  </nav>
			  <article>
			    Interesting Stuff to Read
			  </article>
			</div>
		</figure>

		<pre>
			&lt;style>
			  @media (min-width: 60em) {
			    /* <a href="http://www.w3.org/TR/css3-mediaqueries/#width">two column layout only when enough room</a> (relative to default text size) */
			    header + div { display: flex; }
			    #main {
			      flex: 1;         /* <a href="#flexibility">Main takes up all remaining space</a> */
			      order: 1;        /* <a href="#order-property">Place it after (to the right of) the navigation</a> */
			      min-width: 12em; /* Optimize main content area sizing */
			    }
			  }
			  /* menu items use flex layout so that visibility:collapse will work */
			  nav > ul > li {
			    display: flex;
			    flex-flow: column;
			  }
			  /* dynamically collapse submenus when not targetted */
			  nav > ul > li:not(:target):not(:hover) > ul {
			    visibility: collapse;
			  }
			&lt;/style>
			&hellip;
			&lt;/header>
			&lt;div>
			  &lt;article id="main">
			    Interesting Stuff to Read
			  &lt;/article>
			  &lt;nav>
			    &lt;ul>
			      &lt;li id="nav-about">&lt;a href="#nav-about">About&lt;/a>
			        &hellip;
			      &lt;li id="nav-projects">&lt;a href="#nav-projects">Projects&lt;/a>
			        &lt;ul>
			          &lt;li>&lt;a href="&hellip;">Art&lt;/a>
			          &lt;li>&lt;a href="&hellip;">Architecture&lt;/a>
			          &lt;li>&lt;a href="&hellip;">Music&lt;/a>
			        &lt;/ul>
			      &lt;li id="nav-interact">&lt;a href="#nav-interact">Interact&lt;/a>
			        &hellip;
			    &lt;/ul>
			  &lt;/nav>
			&lt;/div>
			&lt;footer>
			&hellip;
		</pre>
	</div>

	<p>
		To compute the size of the strut, flex layout is first performed with all items uncollapsed,
		and then re-run with each collapsed item replaced by a strut that maintains
		the original cross-size of the item's original line.
		See the <a href="#layout-algorithm">Flex Layout Algorithm</a>
		for the normative definition of how ''visibility:collapse''
		interacts with flex layout.

	<p class='note'>
		Note that using ''visibility:collapse'' on any flex items
		will cause the flex layout algorithm to repeat partway through,
		re-running the most expensive steps.
		It's recommended that authors continue to use ''display:none'' to hide items
		if the items will not be dynamically collapsed and uncollapsed,
		as that is more efficient for the layout engine.
		(Since only part of the steps need to be repeated when 'visibility' is changed,
		however, 'visibility: collapse' is still recommended for dynamic cases.)


<h2 id="flow-order">
Ordering and Orientation</h2>

	<p>
		The contents of a flex container can be laid out in any direction and in any order.
		This allows an author to trivially achieve effects that would previously have required complex or fragile methods,
		such as hacks using the 'float' and 'clear' properties.
		This functionality is exposed through the 'flex-direction', 'flex-wrap', and 'order' properties.

	<p class="note">
		The reordering capabilities of flex layout intentionally affect
		<em>only the visual rendering</em>,
		leaving speech order and navigation based on the source order.
		This allows authors to manipulate the visual presentation
		while leaving the source order intact for non-CSS UAs and for
		linear models such as speech and sequential navigation.
		See <a href="#order-accessibility">Reordering and Accessibility</a>
		and the <a href="#overview">Flex Layout Overview</a> for examples
		that use this dichotomy to improve accessibility.

	<p>
		Authors <em>must not</em> use these techniques as a substitute for correct source ordering,
		as that can ruin the accessibility of the document.

<h3 id='flex-direction-property'>
Flex Flow Direction: the 'flex-direction' property</h3>

	<pre class='propdef'>
	Name: flex-direction
	Value: row | row-reverse | column | column-reverse
	Initial: row
	Applies to: <a>flex containers</a>
	Inherited: no
	Computed value: specified value
	Media: visual
	</pre>

	<p>
		The 'flex-direction' property specifies how <i>flex items</i> are placed in the flex container,
		by setting the direction of the flex container's <i>main axis</i>.
		This determines the direction that flex items are laid out in.

	<dl dfn-type=value dfn-for=flex-direction>
		<dt><dfn>row</dfn>
		<dd>
			The flex container's <i>main axis</i> has the same orientation as the
			<a>inline axis</a>
			of the current <i>writing mode</i>.
			The <i>main-start</i> and <i>main-end</i> directions are equivalent to the
			<a>inline-start</a> and
			<a>inline-end</a> directions, respectively,
			of the current <i>writing mode</i>.

		<dt><dfn>row-reverse</dfn>
		<dd>
			Same as ''row'',
			except the <i>main-start</i> and <i>main-end</i> directions are swapped.

		<dt><dfn>column</dfn>
		<dd>
			The flex container's <i>main axis</i> has the same orientation as the
			<a>block axis</a>
			of the current <i>writing mode</i>.
			The <i>main-start</i> and <i>main-end</i> directions are equivalent to the
			<a>block-start</a> and
			<a>block-end</a> directions, respectively,
			of the current <i>writing mode</i>.

		<dt><dfn>column-reverse</dfn>
		<dd>
			Same as ''column'',
			except the <i>main-start</i> and <i>main-end</i> directions are swapped.
	</dl>

	<p class="note">
		The reverse values do not reverse box ordering;
		like 'writing-mode' and 'direction' [[CSS3-WRITING-MODES]],
		they only change the direction of flow.
		Painting order, speech order, and sequential navigation orders
		are not affected.

<h3 id='flex-wrap-property'>
Flex Line Wrapping: the 'flex-wrap' property</h3>

	<pre class='propdef'>
	Name: flex-wrap
	Value: nowrap | wrap | wrap-reverse
	Initial: nowrap
	Applies to: <a>flex containers</a>
	Inherited: no
	Computed value: specified value
	Media: visual
	</pre>

	<p>
		The 'flex-wrap' property controls whether the flex container is <i>single-line</i> or <i>multi-line</i>,
		and the direction of the <i>cross-axis</i>,
		which determines the direction new lines are stacked in.

	<dl dfn-type=value dfn-for=flex-wrap>
		<dt><dfn>nowrap</dfn>
		<dd>
			The flex container is <i>single-line</i>.
			The <i>cross-start</i> direction is equivalent to either
			the <a>inline-start</a>
			or <a>block-start</a>
			direction of the current <i>writing mode</i>,
			whichever is in the <i>cross axis</i>,
			and the <i>cross-end</i> direction is the opposite direction of <i>cross-start</i>.


		<dt><dfn>wrap</dfn>
		<dd>
			The flex container is <i>multi-line</i>.
			The <i>cross-start</i> direction is equivalent to either
			the <a>inline-start</a>
			or <a>block-start</a>
			direction of the current <i>writing mode</i>,
			whichever is in the <i>cross axis</i>,
			and the <i>cross-end</i> direction is the opposite direction of <i>cross-start</i>.

		<dt><dfn>wrap-reverse</dfn>
		<dd>
			Same as ''wrap'',
			except the <i>cross-start</i> and <i>cross-end</i> directions are swapped.
	</dl>

<h3 id='flex-flow-property'>
Flex Direction and Wrap: the 'flex-flow' shorthand</h3>

	<pre class='propdef'>
	Name: flex-flow
	Value: <'flex-direction'> || <'flex-wrap'>
	Initial: see individual properties
	Applies to: <a>flex containers</a>
	Inherited: see individual properties
	Computed value: see individual properties
	Media: visual
	</pre>

	<p>The 'flex-flow' property is a shorthand for setting the 'flex-direction' and 'flex-wrap' properties,
	which together define the flex container's main and cross axes.

	<div class="example">
		<p>Some examples of valid flows in an English (left-to-right, horizontal writing mode) document:

		<table style="margin: 0 auto; vertical-align: middle; border-spacing: 2em 1em;">
			<tr>
				<td><pre>
div { flex-flow: row; }
/* Initial value. Main-axis is
   inline, no wrap. */</pre>
				<td><img src='images/flex-flow1.svg' width=205 height=46 alt>
			<tr>
				<td><pre>
div { flex-flow: column wrap; }
/* Main-axis is block-direction (top to bottom)
   and lines wrap in the inline direction (rightwards). */</pre>
				<td><img src='images/flex-flow2.svg' width=89 height=160 alt>
			<tr>
				<td><pre>
div { flex-flow: row-reverse wrap-reverse; }
/* Main-axis is the opposite of inline direction
   (right to left). New lines wrap upwards. */</pre>
				<td><img src='images/flex-flow3.svg' width=160 height=89 alt>
		</table>
	</div>

	<div class='note'>
		<p>
			Note that the 'flex-flow' directions are <i>writing mode</i> sensitive.
			In vertical Japanese, for example,
			a ''row'' flex container lays out its contents from top to bottom,
			as seen in this example:

		<table style="margin: 1em auto; text-align: center;">
			<thead>
				<tr>
					<th>English
					<th>Japanese
			<tbody>
				<tr>
					<td><pre>flex-flow: row wrap;<br>writing-mode: horizontal-tb;</pre>
					<td><pre>flex-flow: row wrap;<br>writing-mode: vertical-rl;</pre>
				<tr>
					<td><img src='images/flex-flow-english.svg' alt>
					<td><img src='images/flex-flow-japanese.svg' alt>
		</table>
	</div>



<h3 id='order-property'>
Display Order: the 'order' property</h3>

	<p>
		<i>Flex items</i> are, by default, displayed and laid out in the same order as they appear in the source document.
		The 'order' property can be used to change this ordering.

	<pre class='propdef'>
	Name: order
	Value: <<integer>>
	Initial: 0
	Applies to: <a>flex items</a> and absolutely-positioned children of <a>flex containers</a>
	Inherited: no
	Computed value: specified value
	Media: visual
	Animatable: yes
	</pre>

	<p>
		The 'order' property controls the order in which flex items appear within their flex container,
		by assigning them to ordinal groups.
		It takes a single <dfn value for=order><<integer>></dfn> value,
		which specifies which ordinal group the <a>flex item</a> belongs to.

	<p>
		A flex container will lay out its content starting from the lowest numbered ordinal group and going up.
		Items with the same ordinal group are laid out in the order they appear in the source document.
		This also affects the <a href="http://www.w3.org/TR/CSS2/zindex.html">painting order</a> [[!CSS21]],
		exactly as if the elements were reordered in the document.

	<div class='example'>
		<p>The following figure shows a simple tabbed interface, where the tab for the active pane is always first:

		<div class='figure'><img src="images/flex-order-example.png" alt></div>

		<p>This could be implemented with the following CSS (showing only the relevant code):

		<pre>
.tabs {
	display: flex;
}
.tabs > * {
	min-width: min-content;
	/* Prevent tabs from getting too small for their content. */
}
.tabs > .current {
	order: -1; /* Lower than the default of 0 */
}</pre>

	</div>

	<p>
		Unless otherwise specified by a future specification,
		this property has no effect on elements that are not <i>flex items</i>.

<!--
	<p class='note'>
		It is expected that future layout modes like Grid Layout
		will also use 'order' for similar purposes.
-->

<h4 id="order-accessibility">
Reordering and Accessibility</h4>

	<p>
		The 'order' property <em>does not</em> affect ordering in non-visual media
		(such as <a href="http://www.w3.org/TR/css3-speech/">speech</a>).
		Likewise, 'order' does not affect
		the default traversal order of sequential navigation modes
		(such as cycling through links, see e.g. 'nav-index' [[CSS3UI]] or <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#sequential-focus-navigation-and-the-tabindex-attribute"><code>tabindex</code></a> [[HTML40]]).
		Authors <em>must</em> use 'order' only for visual, not logical, reordering of content;
		style sheets that use 'order' to perform logical reordering are non-conforming.
	<p class='note'>
		This is so that non-visual media and non-CSS UAs,
		which typically present content linearly,
		can rely on a logical source order,
		while 'order' is used to tailor the visual order.
		(Since visual perception is two-dimensional and non-linear,
		the desired visual order is not always logical.)

	<div class='example'>
		<p>
			Many web pages have a similar shape in the markup,
			with a header on top,
			a footer on bottom,
			and then a content area and one or two additional columns in the middle.
			Generally,
			it's desirable that the content come first in the page's source code,
			before the additional columns.
			However, this makes many common designs,
			such as simply having the additional columns on the left and the content area on the right,
			difficult to achieve.
			This has been addressed in many ways over the years,
			often going by the name "Holy Grail Layout" when there are two additional columns.
			'order' makes this trivial.
			For example, take the following sketch of a page's code and desired layout:

		<div class='code-and-figure'>
			<div><pre>
&lt;!DOCTYPE html>
&lt;header>...&lt;/header>
&lt;div id='main'>
   &lt;article>...&lt;/article>
   &lt;nav>...&lt;/nav>
   &lt;aside>...&lt;/aside>
&lt;/div>
&lt;footer>...&lt;/footer></pre></div>
			<div><img src="images/flex-order-page.svg" width=400 height=360 alt="In this page the header is at the top and the footer at the bottom, but the article is in the center, flanked by the nav on the right and the aside on the left."></div>
		</div>

		<p>
			This layout can be easily achieved with flex layout:

		<pre>
#main { display: flex; }
#main > article { order: 2; min-width: 12em; flex:1; }
#main > nav     { order: 1; width: 200px; }
#main > aside   { order: 3; width: 200px; }</pre>

		<p>
			As an added bonus,
			the columns will all be <a href="#align-stretch">equal-height</a> by default,
			and the main content will be as wide as necessary to fill the screen.
			Additionally,
			this can then be combined with media queries to switch to an all-vertical layout on narrow screens:

		<pre>
@media all and (max-width: 600px) {
	/* Too narrow to support three columns */
	#main { flex-flow: column; }
	#main > article, #main > nav, #main > aside {
		/* Return them to document order */
		order: 0; width: auto;
	}
}</pre>

		<p><small>(Further use of multi-line flex containers to achieve even more intelligent wrapping left as an exercise for the reader.)</small>
	</div>

<h2 id='flex-lines'>
Flex Lines</h2>

	<p>
		<a>Flex items</a> in a <a>flex container</a> are laid out and aligned
		within <dfn title="flex line">flex lines</dfn>,
		hypothetical containers used for grouping and alignment by the layout algorithm.
		A flex container can be either <i>single-line</i> or <i>multi-line</i>,
		depending on the 'flex-wrap' property:
	<ul>
		<li>
			A <dfn>single-line</dfn> flex container lays out all of its children in a single line,
			even if that would cause its contents to overflow.

		<li>
			A <dfn>multi-line</dfn> flex container breaks its <i>flex items</i> across multiple lines,
			similar to how text is broken onto a new line when it gets too wide to fit on the existing line.
			When additional lines are created,
			they are stacked in the flex container along the <i>cross axis</i>
			according to the 'flex-wrap' property.
			Every line contains at least one <i>flex item</i>,
			unless the flex container itself is completely empty.
	</ul>

	<div class=example>
		<p>
			This example shows four buttons that do not fit horizontally.

		<pre>&lt;style>
#flex {
	display: flex;
	flex-flow: row wrap;
	width: 300px;
}
.item {
	width: 80px;
}
&lt;/style>

&lt;div id="flex">
	&lt;div class='item'>1&lt;/div>
	&lt;div class='item'>2&lt;/div>
	&lt;div class='item'>3&lt;/div>
	&lt;div class='item'>4&lt;/div>
&lt;/div></pre>

		<p>
			Since the container is 300px wide, only three of the items fit onto a single line.
			They take up 240px, with 60px left over of remaining space.
			Because the 'flex-flow' property specifies a <i>multi-line</i> flex container
			(due to the ''wrap'' keyword appearing in its value),
			the flex container will create an additional line to contain the last item.

		<figure>
			<img src="images/multiline-no-flex.svg">

			<figcaption>
				An example rendering of the multi-line flex container.
			</figcaption>
		</figure>
	</div>

	<p>
		Once content is broken into lines,
		each line is laid out independently;
		flexible lengths and the 'justify-content' and 'align-self' properties only consider the items on a single line at a time.

	<p>
		When a flex container has multiple lines, the <i>cross size</i> of each line
		is the minimum size necessary to contain the <i>flex items</i> on the line
		(after aligment due to 'align-self'),
		and the lines are aligned within the flex container with the 'align-content' property.
		When a flex container (even a <i>multi-line</i> one) has only one line,
		the <i>cross size</i> of the line is the <i>cross size</i> of the flex container,
		and 'align-content' has no effect.
		The <i>main size</i> of a line is always the same as the <i>main size</i> of the flex container's content box.

	<div class='example'>
		<p>
			Here's the same example as the previous,
			except that the flex items have all been given ''flex: auto''.
			The first line has 60px of remaining space,
			and all of the items have the same flexibility,
			so each of the three items on that line will receives 20px of extra width,
			ending up 100px wide.
			The remaining item is on a line of its own
			and will stretch to the entire width of the line, or 300px.

		<figure>
			<img src="images/multiline-flex.svg">

			<figcaption>
				A rendering of the same as above,
				but with the items all given ''flex: auto''.
			</figcaption>
		</figure>
	</div>



<h2 id='flexibility'>
Flexibility</h2>

	<p>
		The defining aspect of flex layout is the ability to make the <i>flex items</i> "flex",
		altering their width or height to fill the available space.
		This is done with the 'flex' property.
		A flex container distributes free space to its items proportional to their <i>flex grow factor</i>,
		or shrinks them to prevent overflow proportional to their <i>flex shrink factor</i>.


<h3 id='flex-property'>
The 'flex' Shorthand</h3>

	<pre class='propdef'>
	Name: flex
	Value: none | [ <<'flex-grow'>> <<'flex-shrink'>>? || <<'flex-basis'>> ]
	Initial: see individual properties
	Applies to: <a>flex items</a>
	Inherited: see individual properties
	Computed value: see individual properties
	Media: visual
	Canonical order: per grammar
	</pre>

	<p>
		The 'flex' property specifies the components of a <dfn>flexible length</dfn>:
		the <i>flex grow factor</i>
		and <i>flex shrink factor</i>,
		and the <i>flex basis</i>.
		When an element is a <i>flex item</i>,
		'flex' is consulted <em>instead of</em> the <i>main size property</i>
		to determine the <i>main size</i> of the element.
		If an element is not a <i>flex item</i>,
		'flex' has no effect.

	<dl dfn-type=value dfn-for=flex>
		<dt><dfn><<'flex-grow'>></dfn>
		<dd>
			<p>
				This <var>&lt;number></var> component sets 'flex-grow' <a href="#flex-components">longhand</a>
				and specifies the <dfn dfn>flex grow factor</dfn>,
				which determines how much the <i>flex item</i> will grow
				relative to the rest of the <i>flex items</i> in the flex container
				when positive free space is distributed.
				When omitted, it is set to ''1''.

		<dt><dfn><<'flex-shrink'>></dfn>
		<dd>
			<p>
				This <var>&lt;number></var> component sets 'flex-shrink' <a href="#flex-components">longhand</a>
				and specifies the <dfn dfn>flex shrink factor</dfn>,
				which determines how much the <i>flex item</i> will shrink
				relative to the rest of the <i>flex items</i> in the flex container
				when negative free space is distributed.
				When omitted, it is set to ''1''.
				The <i>flex shrink factor</i> is multiplied by the <i>flex basis</i> when distributing negative space.

		<dt><dfn><<'flex-basis'>></dfn>
		<dd>
			<p>
				This component, which takes the same values as the 'width' property,
				sets the 'flex-basis' <a href="#flex-components">longhand</a>
				and specifies the <dfn dfn>flex basis</dfn>:
				the initial <i>main size</i> of the <i>flex item</i>,
				before free space is distributed according to the flex factors.
				When omitted from the 'flex' shorthand, its specified value is ''0%''.
			<p>
				If the specified 'flex-basis' is <a value for=flex-basis>auto</a>,
				the used <i>flex basis</i> is the value of the element's <i>main size property</i>.
				(This can itself be the keyword <a value for=width>auto</a>, which sizes the element based on its contents.)

			<figure>
				<img src='images/rel-vs-abs-flex.svg' width='504' height='240'>
				<figcaption>
					A diagram showing the difference between "absolute" flex
					(starting from a basis of zero)
					and "relative" flex
					(starting from a basis of the item's content size).
					The three items have flex factors of ''1'', ''1'', and ''2'', respectively.
				</figcaption>
			</figure>

		<dt><dfn>none</dfn>
		<dd>
			<p>The keyword ''none'' computes to ''0 0 auto''.
	</dl>

	<p>
		The initial values of the 'flex' components are equivalent to <a href="#flex-initial">''flex: 0 1 auto''</a>.
	<p class="note">
		Note that the initial values of 'flex-grow' and 'flex-basis'
		are different from their defaults when omitted in the 'flex' shorthand.
		This so that the 'flex' shorthand can better accommodate the most <a href="#flex-common">common cases</a>.

	<p>
		A unitless zero that is not already preceded by two flex factors
		must be interpreted as a flex factor.
		To avoid misinterpretation or invalid declarations,
		authors must specify a zero <<'flex-basis'>> component
		with a unit or precede it by two flex factors.

<h3 id='flex-common'>
Common Values of 'flex'</h3>

	<p><em>This section is informative.</em>

	<p>
		The list below summarizes the effects of the most common 'flex' values:

	<dl>
		<dt id="flex-initial">''flex: 0 auto''
		<dt>''flex: initial''
		<dd>
			Equivalent to ''flex: 0 1 auto''. (This is the initial value.)
			Sizes the item based on the 'width'/'height' properties.
			(If the item's <i>main size property</i> computes to <a value for=width>auto</a>,
			this will size the flex item based on its contents.)
			Makes the flex item inflexible when there is positive free space,
			but allows it to shrink to its min-size when there is insufficient space.
			The <a href="#alignment">alignment abilities</a> or <a href="#auto-margins"><span class=css>auto</span> margins</a>
			can be used to align flex items along the <i>main axis</i>.

		<dt>''flex: auto''
		<dd>
			Equivalent to ''flex: 1 1 auto''.
			Sizes the item based on the 'width'/'height' properties,
			but makes them fully flexible, so that they absorb any free space along the <i>main axis</i>.
			If all items are either ''flex: auto'', ''flex: initial'', or ''flex: none'',
			any positive free space after the items have been sized will be distributed evenly to the items with ''flex: auto''.

		<dt>''flex: none''
		<dd>
			Equivalent to ''flex: 0 0 auto''.
			This value sizes the item according to the 'width'/'height' properties,
			but makes the flex item fully inflexible.
			This is similar to <a href="#flex-initial">''initial''</a>,
			except that flex items are not allowed to shrink,
			even in overflow situations.

		<dt>''flex: &lt;positive-number>''
		<dd>
			Equivalent to ''flex: &lt;positive-number> 1 0%''.
			Makes the flex item flexible and sets the <i>flex basis</i> to zero,
			resulting in an item that receives the specified proportion of the free space in the flex container.
			If all items in the flex container use this pattern,
			their sizes will be proportional to the specified flex factor.
	</dl>

	<div class='note'>
		Note that, because flex items typically can shrink,
		it is often recommended that a minimum main size be set
		(with 'min-width' or 'min-height')
		to prevent them from shrinking too small to fit their contents.
		This problem is especially common with horizontal navigation or toolbars.

		<pre>nav li { flex: 1; min-width: min-content; /* Don't overflow */}</pre>
	</div>

<h3 id='flex-components'>
Components of Flexibility</h3>

	<p>
		Individual components of flexibility can be controlled by independent longhand properties.

	<p class='note'>
		Authors are encouraged to control flexibility using the 'flex' shorthand
		rather than with component properties,
		as the shorthand correctly resets any unspecified components
		to accommodate <a href="#flex-common">common uses</a>.

<h4 id='flex-grow-property'>
The 'flex-grow' property</h4>

	<pre class='propdef'>
	Name: flex-grow
	Value: <<number>>
	Initial: 0
	Applies to: <a>flex items</a>
	Inherited: no
	Computed value: specified value
	Media: visual
	Animatable: yes, except between ''0'' and other values
	</pre>

	<p>
		The 'flex-grow' property sets the <i>flex grow factor</i>
		to the provided <dfn value for=flex-grow><<number>></dfn>.
		Negative numbers are invalid.

<h4 id='flex-shrink-property'>
The 'flex-shrink' property</h4>

	<pre class='propdef'>
	Name: flex-shrink
	Value: <<number>>
	Initial: 1
	Applies to: <a>flex items</a>
	Inherited: no
	Computed value: specified value
	Media: visual
	Animatable: yes, except between ''0'' and other values
	</pre>

	<p>
		The 'flex-shrink' property sets the <i>flex shrink factor</i>
		to the provided <dfn value for=flex-shrink><<number>></dfn>.
		Negative numbers are invalid.

<h4 id='flex-basis-property'>
The 'flex-basis' property</h4>

	<pre class='propdef'>
	Name: flex-basis
	Value: auto | <<'width'>>
	Initial: auto
	Applies to: <a>flex items</a>
	Inherited: no
	Computed value: as specified, with lengths made absolute
	Percentages: realtive to the <a>flex container's</a> inner <i>main size</i>
	Media: visual
	Animatable: as 'width'
	</pre>

	<p>
		The 'flex-basis' property sets the <i>flex basis</i>.
		Negative lengths are invalid.

	<p>
		Except for <dfn value for=flex-basis>auto</dfn>,
		which retrieves the value of the <i>main size property</i>,
		'flex-basis' is resolved the same way as 'width' in horizontal writing modes [[!CSS21]]:
		percentage values of 'flex-basis' are resolved against
		the flex item's containing block, i.e. its flex container,
		and if that containing block's size is <a>indefinite</a>,
		the result is the same as a <i>main size</i> of <a value for=width>auto</a>.
		Similarly, 'flex-basis' determines the size of the content box,
		unless otherwise specified
		such as by 'box-sizing' [[CSS3UI]].

<h2 id='alignment'>
Alignment</h2>

	<p>
		After a flex container's contents have finished their flexing
		and the dimensions of all flex items are finalized,
		they can then be aligned within the flex container.

	<p>
		The 'margin' properties can be used to align items in a manner similar to, but more powerful than, what margins can do in block layout.
		<i>Flex items</i> also respect the alignment properties from the Box Alignment spec,
		which allow easy keyword-based alignment of items in both the <i>main axis</i> and <i>cross axis</i>.
		These properties make many common types of alignment trivial,
		including some things that were very difficult in CSS 2.1,
		like horizontal and vertical centering.

	<p class='note'>
		While the alignment properties are defined in the Box Alignment spec,
		Flexible Box Layout reproduces the definitions of the relevant ones here
		so as to not create a normative dependency that may slow down advancement of the spec.
		These properties apply only to flex layout
		until Box Alignment is finished
		and defines their effect for other layout modes.


<h3 id='auto-margins'>
Aligning with <a value for=margin>auto</a> margins</h3>

	<p>
		<em>This section is non-normative.
			The normative definition of how margins affect flex items is in the <a href="#layout-algorithm">Flex Layout Algorithm</a> section.</em>

	<p>
		Auto margins on flex items have an effect very similar to auto margins in block flow:

	<ul>
		<li>
			During calculations of flex bases and flexible lengths, auto margins are treated as ''0''.

		<li>
			Prior to alignment via 'justify-content' and 'align-self',
			any positive free space is distributed to auto margins in that dimension.

		<li>
			Overflowing elements ignore their auto margins and overflow in the <i>end</i> direction.
	</ul>

	<p class='note'>
		Note that, if free space is distributed to auto margins,
		the alignment properties will have no effect in that dimension
		because the margins will have stolen all the free space
		left over after flexing.

	<div class='example'>
		<p>
			One use of <a value for=margin>auto</a> margins in the main axis is to separate flex items into distinct "groups".
			The following example shows how to use this to reproduce a common UI pattern -
			a single bar of actions with some aligned on the left and others aligned on the right.

		<figure>
			<figcaption>
				Sample rendering of the code below.
			</figcaption>
			<ul id='auto-bar'>
				<li><a href=#>About</a>
				<li><a href=#>Projects</a>
				<li><a href=#>Interact</a>
				<li id='login'><a href=#>Login</a>
			</ul>
		</figure>

		<pre>
&lt;style>
nav > ul {
	display: flex;
}
nav > ul > li {
	min-width: min-content;
	/* Prevent items from getting too small for their content. */
}
nav > ul > #login {
	margin-left: auto;
}
&lt;/style>
&lt;nav>
	&lt;ul>
		&lt;li>&lt;a href=/about>About&lt;/a>
		&lt;li>&lt;a href=/projects>Projects&lt;/a>
		&lt;li>&lt;a href=/interact>Interact&lt;/a>
		&lt;li id='login'>&lt;a href=/login>Login&lt;/a>
	&lt;/ul>
&lt;/nav></pre>
	</div>

	<div class='example'>
		<p>
			The figure below illustrates the difference in cross-axis alignment in overflow situations between
			using <a href="#auto-margins"><span class=css>auto</span> margins</a>
			and using the <a href='#align-items-property'>alignment properties</a>.

		<figure>
			<div style="display:table; margin: 0 auto 1em;">
				<div style="display:table-cell; padding-right: 50px;" class='cross-auto-figure'>
					<div>
						<div>About</div>
						<div>Authoritarianism</div>
						<div>Blog</div>
					</div>
				</div>
				<div style="display:table-cell; padding-left: 50px;" class='cross-auto-figure'>
					<div>
						<div>About</div>
						<div style="margin-left: -31px;">Authoritarianism</div>
						<div>Blog</div>
					</div>
				</div>
			</div>
			<figcaption>
				The items in the figure on the left are centered with margins,
				while those in the figure on the right are centered with 'align-self'.
				If this column flex container was placed against the left edge of the page,
				the margin behavior would be more desirable,
				as the long item would be fully readable.
				In other circumstances,
				the true centering behavior might be better.
			</figcaption>
		</figure>
	</div>

<h3 id='justify-content-property'>
Axis Alignment: the 'justify-content' property</h3>

	<pre class='propdef'>
	Name: justify-content
	Value: flex-start | flex-end | center | space-between | space-around
	Initial: flex-start
	Applies to: <a>flex containers</a>
	Inherited: no
	Computed value: specified value
	Media: visual
	</pre>

	<p>
		The 'justify-content' property aligns <i>flex items</i> along the <i>main axis</i> of the current line of the flex container.
		This is done <em title=''>after</em> any flexible lengths and any <a href="#auto-margins">auto margins</a> have been resolved.
		Typically it helps distribute extra free space leftover when either
		all the <i>flex items</i> on a line are inflexible,
		or are flexible but have reached their maximum size.
		It also exerts some control over the alignment of items when they overflow the line.

	<dl dfn-type=value dfn-for=justify-content>
		<dt><dfn>flex-start</dfn>
		<dd>
			<i>Flex items</i> are packed toward the start of the line.
			The <i>main-start</i> margin edge of the first <i>flex item</i> on the line
			is placed flush with the <i>main-start</i> edge of the line,
			and each subsequent <i>flex item</i> is placed flush with the preceding item.

		<dt><dfn>flex-end</dfn>
		<dd>
			<i>Flex items</i> are packed toward the end of the line.
			The <i>main-end</i> margin edge of the last <i>flex item</i>
			is placed flush with the <i>main-end</i> edge of the line,
			and each preceding <i>flex item</i> is placed flush with the subsequent item.

		<dt><dfn>center</dfn>
		<dd>
			<i>Flex items</i> are packed toward the center of the line.
			The <i>flex items</i> on the line are placed flush with each other
			and aligned in the center of the line,
			with equal amounts of empty space between the <i>main-start</i> edge of the line and the first item on the line
			and between the <i>main-end</i> edge of the line and the last item on the line.
			(If the leftover free-space is negative,
			the <i>flex items</i> will overflow equally in both directions.)

		<dt><dfn>space-between</dfn>
		<dd>
			<i>Flex items</i> are evenly distributed in the line.
			If the leftover free-space is negative
			or there is only a single <i>flex item</i> on the line,
			this value is identical to <a value for=justify-content>flex-start</a>.
			Otherwise,
			the <i>main-start</i> margin edge of the first <i>flex item</i> on the line
			is placed flush with the <i>main-start</i> edge of the line,
			the <i>main-end</i> margin edge of the last <i>flex item</i> on the line
			is placed flush with the <i>main-end</i> edge of the line,
			and the remaining <i>flex items</i> on the line are distributed
			so that the spacing between any two adjacent items is the same.

		<dt><dfn>space-around</dfn>
		<dd>
			<i>Flex items</i> are evenly distributed in the line,
			with half-size spaces on either end.
			If the leftover free-space is negative or
			there is only a single <i>flex item</i> on the line,
			this value is identical to <a value for=justify-content>center</a>.
			Otherwise, the <i>flex items</i> on the line are distributed
			such that the spacing between any two adjacent <i>flex items</i> on the line is the same,
			and the spacing between the first/last <i>flex items</i> and the <i>flex container</i> edges
			is half the size of the spacing between <i>flex items</i>.
	</dl>

	<div class="figure">
		<img src="images/flex-pack.svg" width=504 height=270 alt>
		<p class='caption'>An illustration of the five 'justify-content' keywords and their effects on a flex container with three colored items.
	</div>


<h3 id='align-items-property'>
Cross-axis Alignment: the 'align-items' and 'align-self' properties</h3>

	<pre class='propdef'>
	Name: align-items
	Value: flex-start | flex-end | center | baseline | stretch
	Initial: stretch
	Applies to: <a>flex containers</a>
	Inherited: no
	Computed value: specified value
	Media: visual
	</pre>

	<pre class='propdef'>
	Name: align-self
	Value: auto | flex-start | flex-end | center | baseline | stretch
	Initial: auto
	Applies to: <a>flex items</a>
	Inherited: no
	Computed value: <a value for=align-self>auto</a> computes to parent's 'align-items' value; otherwise as specified
	Media: visual
	</pre>

	<p>
		<i>Flex items</i> can be aligned in the <i>cross axis</i> of the current line of the flex container,
		similar to 'justify-content' but in the perpendicular direction.
		'align-items' sets the default alignment for all of the flex container's <i title="flex items">items</i>,
		including anonymous <i>flex items</i>.
		'align-self' allows this default alignment to be overridden for individual <i>flex items</i>.
		(For anonymous flex items,
		'align-self' always matches the value of 'align-items' on their associated flex container.)

	<p>
		If either of the <i>flex item's</i> cross-axis margins are <a value for=margin>auto</a>,
		'align-self' has no effect.

	<p>
		A value of <dfn value for=align-self>auto</dfn> for 'align-self'
		computes to the value of 'align-items' on the element's parent,
		or <a value for=align-self>stretch</a> if the element has no parent.
		The alignments are defined as:

	<dl dfn-type=value dfn-for="align-items align-self">
		<dt><dfn>flex-start</dfn>
		<dd>
			The <i>cross-start</i> margin edge of the <i>flex item</i>
			is placed flush with the <i>cross-start</i> edge of the line.

		<dt><dfn>flex-end</dfn>
		<dd>
			The <i>cross-end</i> margin edge of the <i>flex item</i>
			is placed flush with the <i>cross-end</i> edge of the line.

		<dt><dfn>center</dfn>
		<dd>
			The <i>flex item</i>&apos;s margin box is centered in the <i>cross axis</i> within the line.
			(If the <i>cross size</i> of the flex line is less than that of the <i>flex item</i>,
			it will overflow equally in both directions.)

		<dt><dfn>baseline</dfn>
		<dd>
			<p>
				If the <i>flex item</i>&apos;s inline axis is the same as the <i>cross axis</i>,
				this value is identical to <a value for=align-self>flex-start</a>.

			<p>
				Otherwise,
				it <dfn dfn id='baseline-participation'>participates in baseline alignment</dfn>:
				all participating <i>flex items</i> on the line
				are aligned such that their baselines align,
				and the item with the largest distance between its baseline and its <i>cross-start</i> margin edge
				is placed flush against the <i>cross-start</i> edge of the line.


		<dt><dfn>stretch</dfn>
		<dd>
			<p>
				If the <i>cross size property</i> of the <i>flex item</i> computes to <a value for=width>auto</a>,
				its used value is the length necessary to make the <i>cross size</i> of the item's margin box as close to the same size as the line as possible,
				while still respecting the constraints imposed by 'min-height'/'min-width'/'max-height'/'max-width'.

			<p class='note'>
				Note that if the flex container's height is constrained
				this value may cause the contents of the <i>flex item</i>
				to overflow the item.

			<p>
				The <i>cross-start</i> margin edge of the <i>flex item</i>
				is placed flush with the <i>cross-start</i> edge of the line.
	</dl>

	<div class='figure'>
		<img src="images/flex-align.svg" width=508 height=377 alt>
		<p class='caption'>An illustration of the five 'align-items' keywords and their effects on a flex container with four colored items.
	</div>

<h3 id='align-content-property'>
Packing Flex Lines: the 'align-content' property</h3>

	<pre class='propdef'>
	Name: align-content
	Value: flex-start | flex-end | center | space-between | space-around | stretch
	Initial: stretch
	Applies to: <a>multi-line</a> <a>flex containers</a>
	Inherited: no
	Computed value: specified value
	Media: visual
	</pre>

	<p>
		The 'align-content' property aligns a flex container's lines within the flex container
		when there is extra space in the <i>cross-axis</i>,
		similar to how 'justify-content' aligns individual items within the <i>main-axis</i>.
		Note, this property has no effect when the flex container has only a single line.
		Values have the following meanings:

	<dl dfn-type=value dfn-for=align-content>
		<dt><dfn>flex-start</dfn>
		<dd>
			Lines are packed toward the start of the flex container.
			The <i>cross-start</i> edge of the first line in the flex container
			is placed flush with the <i>cross-start</i> edge of the flex container,
			and each subsequent line is placed flush with the preceding line.

		<dt><dfn>flex-end</dfn>
		<dd>
			Lines are packed toward the end of the flex container.
			The <i>cross-end</i> edge of the last line
			is placed flush with the <i>cross-end</i> edge of the flex container,
			and each preceding line is placed flush with the subsequent line.

		<dt><dfn>center</dfn>
		<dd>
			Lines are packed toward the center of the flex container.
			The lines in the flex container are placed flush with each other
			and aligned in the center of the flex container,
			with equal amounts of empty space
			between the <i>cross-start</i> content edge of the flex container
			and the first line in the flex container,
			and between the <i>cross-end</i> content edge of the flex container
			and the last line in the flex container.
			(If the leftover free-space is negative,
			the lines will overflow equally in both directions.)

		<dt><dfn>space-between</dfn>
		<dd>
			Lines are evenly distributed in the flex container.
			If the leftover free-space is negative
			this value is identical to <a value for=align-content>flex-start</a>.
			Otherwise,
			the <i>cross-start</i> edge of the first line in the flex container
			is placed flush with the <i>cross-start</i> content edge of the flex container,
			the <i>cross-end</i> edge of the last line in the flex container
			is placed flush with the <i>cross-end</i> content edge of the flex container,
			and the remaining lines in the flex container are distributed
			so that the spacing between any two adjacent lines is the same.

		<dt><dfn>space-around</dfn>
		<dd>
			Lines are evenly distributed in the flex container,
			with half-size spaces on either end.
			If the leftover free-space is negative
			this value is identical to <a value for=align-content>center</a>.
			Otherwise, the lines in the flex container are distributed
			such that the spacing between any two adjacent lines is the same,
			and the spacing between the first/last lines and the <i>flex container</i> edges
			is half the size of the spacing between <i>flex lines</i>.

		<dt><dfn>stretch</dfn>
		<dd>
			Lines stretch to take up the remaining space.
			If the leftover free-space is negative,
			this value is identical to <a value for=align-content>flex-start</a>.
			Otherwise,
			the free-space is split equally between all of the lines,
			increasing their cross size.
	</dl>

	<p class='note'>
		Note: Only flex containers with multiple lines
		ever have free space in the <i>cross-axis</i> for lines to be aligned in,
		because in a flex container with a single line
		the sole line automatically stretches to fill the space.

	<div class="figure">
		<img src="images/align-content-example.svg" width=612 height=508 alt>
		<p class='caption'>
			An illustration of the 'align-content' keywords and their effects on a <i>multi-line</i> flex container.
	</div>

<h3 id="flex-baselines">
Flex Baselines</h3>

	<p>
		The baselines of a flex container are determined as follows (after reordering with 'order'):

	<dl>
		<dt><dfn export>main-axis baseline</dfn>
		<dd>
			<ol>
				<li>
					If any of the <i>flex items</i> on the flex container's first line
					<a href="#baseline-participation">participate in baseline alignment</a>,
					the flex container's <i>main-axis baseline</i> is the baseline of those <i>flex items</i>.

				<li>
					Otherwise, if the flex container has at least one <i>flex item</i>,
					and its first <i>flex item</i> has a baseline
					parallel to the flex container's <i>main axis</i>,
					the flex container's <i>main-axis baseline</i> is that baseline.

				<li>
					Otherwise, the flex container's <i>main-axis baseline</i> is <a href="http://www.w3.org/TR/css3-writing-modes/#inline-alignment">synthesized</a>
					from the first item's content box,
					or, failing that, from the flex container's content box.

					<!--
						Logic behind this choice (because it's different than other baseline calculations):
						If a flexbox has content, the baseline will definitely be inside the flexbox's content box.
						Thus, using the *flexbox's* content box keeps this fairly consistent -
						you don't suddenly jump outside the content box when you delete the last bit of content.
					-->
			</ol>

		<dt><dfn export>cross-axis baseline</dfn>
		<dd>
			<ol>
				<li>
					If the flex container has at least one <i>flex item</i>,
					and its first <i>flex item</i> has a baseline
					parallel to the flex container's <i>cross axis</i>,
					the flex container's <i>cross-axis baseline</i> is that baseline.

				<li>
					Otherwise, the flex container's <i>cross-axis baseline</i> is <a href="http://www.w3.org/TR/css3-writing-modes/#inline-alignment">synthesized</a>
					from the first item's content box,
					or, failing that, from the flex container's content box.
			</ol>
	</dl>

	<p>
		When calculating the baseline according to the above rules,
		if the box contributing a baseline has an 'overflow' value that allows scrolling,
		the box must be treated as being in its initial scroll position
		for the purpose of determining its baseline.

	<p>
		When <a href="http://www.w3.org/TR/CSS21/tables.html#height-layout">determining the baseline of a table cell</a>,
		a flex container provides a baseline just as a line box or table-row does. [[!CSS21]]

	<div class='note'>
		<p>
			CSS 2.1 did not define the baseline of block or table boxes.
			It is expected that they will be defined consistent with those of <a href="http://www.w3.org/TR/CSS2/tables.html#height-layout">table cells</a>,
			as follows:

		<dl>
			<dt>''block''
			<dt>''list-item''
			<dd>
				<p>
					The inline-axis baseline of a block is the baseline of the first in-flow line box in the block,
					or the first in-flow block-level child in the block that has a baseline,
					whichever comes first.
					If there is no such line box or child,
					then the block has no baseline.
					For the purposes of finding a baseline,
					in-flow boxes with a scrolling mechanisms (see the 'overflow' property)
					must be considered as if scrolled to their origin position.

				<p>
					A block has no block-axis baseline.

			<dt>''table''
			<dd>
				<p>
					The inline-axis baseline of a table box is the baseline of its first row.
					However, when calculating the baseline of an inline-block,
					table boxes must be skipped.

				<p>
					The block-axis baseline of a table is undefined.
		</dl>
	</div>



<h2 id='layout-algorithm'>
Flex Layout Algorithm</h2>

	<p>
		This section contains normative algorithms
		detailing the exact layout behavior of a flex container and its contents.
		The algorithms here are written to optimize readability and theoretical simplicity,
		and may not necessarily be the most efficient.
		Implementations may use whatever actual algorithms they wish,
		but must produce the same results as the algorithms described here.

	<p class='note'>
		This section is mainly intended for implementors.
		Authors writing web pages should generally be served well by the individual property descriptions,
		and do not need to read this section unless they have a deep-seated urge to understand arcane details of CSS layout.

	<p>
		For the purposes of these definitions,
		a <dfn title="definite|definite size">definite size</dfn> is one that can be determined without measuring content,
		i.e. is a <var>&lt;length></var>,
		a size of the initial containing block,
		or a <var>&lt;percentage></var> that is resolved against a definite size.
		If a <i>single-line</i> <i>flex container</i> has a definite cross size,
		any <i>flex items</i> with ''align-self: stretch'' must also be treated as having a definite cross size
		(since its size is determined from the size of the <i>flex container</i>).
		An <dfn title="indefinite|indefinite size">indefinite size</dfn> is one that is not <i>definite</i>.

	<p>
		The following sections define the algorithm for laying out a flex container and its contents.

<h3 id='box-manip'>
Initial Setup</h3>

	<ol start=0>
		<li id='algo-anon-box'>
			<strong>Generate anonymous flex items</strong>
			as described in the <a href="#flex-items">Flex Items</a> section.

		<li id='algo-flex-order'>
			<strong>Re-order the flex items and absolutely positioned flex container children according to their 'order'.</strong>
			The elements with the lowest (most negative) 'order' values are first in the ordering.
			If multiple elements share an 'order' value,
			they're ordered by document order.
			This affects the order in which the elements generate boxes in the box-tree,
			and how the rest of this algorithm deals with the generated flex items.
	</ol>

<h3 id='line-sizing'>
Line Length Determination</h3>

	<ol class=continue>
		<li id='algo-available'>
			<strong>Determine the available main and cross space for the flex items.</strong>
			For each dimension,
			if that dimension of the <i>flex container</i>’s content box is a <i>definite size</i>, use that;
			otherwise, subtract the <i>flex container</i>’s margin, border, and padding
			from the space available to the flex container in that dimension
			and use that value.
			<span class='note'>This might result in an infinite value.</span>
			<!-- Maybe???
			For this purpose,
			the block axis of a block container(?)
			always provides infinite available space.
			-->

			<div class='example'>
				<p>For example, the <i>available space</i> to a flex item in a
					<a href="http://www.w3.org/TR/CSS21/visuren.html#floats">floated</a> <a value for=width>auto</a>-sized <i>flex container</i> is:
				<ul>
					<li>the width of the <i>flex container</i>’s containing block minus the <i>flex container</i>’s margin, border, and padding in the horizontal dimension
					<li>infinite in the vertical dimension
				</ul>
			</div>

		<li id='algo-main-item'>
			<strong>Determine the <dfn>flex base size</dfn> and <dfn>hypothetical main size</dfn> of each item:</strong>

			<ul>
				<li>
					If the item has a <i>definite</i> flex basis,
					that's the <i>flex base size</i>.

				<li>
					If the <a>flex basis</a> is <a value for=width>auto</a> or depends on its available size,
					and the flex container is being sized under a min-content or max-content constraint
					(e.g. when performing <a href="http://www.w3.org/TR/CSS21/tables.html#auto-table-layout">automatic table layout</a> [[!CSS21]]),
					size the item under that constraint.
					The <i>flex base size</i> is the item's resulting main size.

				<li>
					If flex item has an intrinsic aspect ratio,
					the flex item has ''align-self: stretch'',
					the <a>flex basis</a> and cross size are both <a value for=width>auto</a> ,
					and the flex container is <i>single-line</i> and has a <i>definite</i> cross size,
					the <i>flex base size</i> is computed from the flex container's inner cross size
					(clamped to the <i>flex item</i>&rsquo;s min and max <i>cross size</i>)
					and the <i>flex item</i>&rsquo;s intrinsic aspect ratio.

					<p class='issue'>
						This substep needs review, see thread at <a href="http://lists.w3.org/Archives/Public/www-style/2012Oct/0781.html">http://lists.w3.org/Archives/Public/www-style/2012Oct/0781.html</a>.

				<li>
					Otherwise,
					if the <a>flex basis</a> is <a value for=width>auto</a> or depends on its available size,
					the available main size is infinite,
					and the flex item's inline axis is parallel to the main axis,
					lay the item out using
					<a href="http://www.w3.org/TR/css3-writing-modes/#orthogonal-flows">the rules for a box in an orthogonal flow</a> [[!CSS3-WRITING-MODES]].
					The <i>flex base size</i> is the item's max-content main size.

				<li>
					Otherwise,
					lay out the item into the available space
					using its flex basis in place of its main size,
					and treating a main size of <a value for=width>auto</a> as ''max-content''.
					The <i>flex base size</i> is the item's resulting main size.

			</ul>

			The <i>hypothetical main size</i> is the item's <i>flex base size</i>
			clamped according to its min and max main size properties.

		<li id='algo-main-container'>
			<strong>Determine the main size of the flex container</strong>
			using the rules of the formatting context in which it participates.
			For this computation, <a value for=margin>auto</a> margins on flex items are treated as ''0''.
	</ol>

<h3 id='main-sizing'>
Main Size Determination</h3>

	<ol class=continue>
		<li id='algo-line-break'>
			<strong>Collect flex items into flex lines:</strong>

			<ul>
				<li>
					If the flex container is <i>single-line</i>,
					collect all the flex items into a single flex line.

				<li>
					Otherwise,
					starting from the first uncollected item,
					collect consecutive items one by one
					until the first time that the <em>next</em> collected item
					would not fit into the flex container's inner main size,
					or until a forced break is encountered.
					If the very first uncollected item wouldn't fit,
					collect just it into the line.
					A break is forced wherever
					the CSS2.1 'page-break-before'/'page-break-after' [[CSS21]]
					or the CSS3 'break-before'/'break-after' [[CSS3-BREAK]] properties
					specify a fragmentation break.

					<p>
						For this step,
						the size of a flex item is its outer <i>hypothetical main size</i>.

					<p>
						Repeat until all flex items have been collected into flex lines.

					<p class='note'>
						Note that the "collect as many" line will collect zero-sized flex items
						onto the end of the previous line
						even if the last non-zero item exactly "filled up" the line.
			</ul>

		<li id='algo-flex'>
			<strong><a href='#resolve-flexible-lengths'>Resolve the flexible lengths</a></strong> of all the flex items
			to find their used main size (see section 9.7.).
	</ol>

<h3 id='cross-sizing'>
Cross Size Determination</h3>

	<ol class=continue>
		<li id='algo-cross-item'>
			<strong>Determine the <dfn>hypothetical cross size</dfn> of each item</strong>
			by performing layout with the used main size and the available space,
			treating <a value for=width>auto</a> as ''fit-content''.

			<p class='note issue'>
				Note that if the flex item's cross size is indefinite,
				any children with percentage cross sizes will be resolved as for <a value for=width>auto</a>.
				However, if the flex item is ''align-self: stretch'',
				these will be resolved in a later step.

		<li id='algo-cross-line'>
			<strong>Calculate the cross size of each flex line.</strong>

			<p>
				If the flex container has only a single line
				(even if it's a <i>multi-line</i> flex container)
				and has a <i>definite</i> cross size,
				the cross size of the flex line
				is the flex container's inner cross size.

			<p>
				Otherwise,
				for each flex line:

			<ol>
				<li>
					Collect all the flex items whose inline-axis is parallel to the main-axis,
					whose 'align-self' is <a href="#align-baseline">''baseline''</a>,
					and whose cross-axis margins are both non-<a value for=margin>auto</a>.
					Find the largest of the distances between each item's baseline and its hypothetical outer cross-start edge,
					and the largest of the distances between each item's baseline and its hypothetical outer cross-end edge,
					and sum these two values.

				<li>
					Among all the items not collected by the previous step,
					find the largest outer <i>hypothetical cross size</i>.

				<li>
					The used cross-size of the flex line is the largest of the numbers found in the previous two steps and zero.
			</ol>

		<li id='algo-line-stretch'>
			<strong>Handle 'align-content: stretch'.</strong>
			If the flex container has a <i>definite</i> cross size,
			'align-content' is <a value for=align-content>stretch</a>,
			and the sum of the flex lines' cross sizes is less than the flex container's inner cross size,
			increase the cross size of each flex line by equal amounts
			such that the sum of their cross sizes exactly equals the flex container's inner cross size.

		<li id='algo-visibility'>
			<strong>Collapse ''visibility:collapse'' items.</strong>
			If any flex items have ''visibility: collapse'',
			note the cross size of the line they're in as the item's <dfn>strut size</dfn>,
			and restart layout from the beginning.

			<p>
				In this second layout round,
				when <a href="#algo-line-break">collecting items into lines</a>,
				treat the collapsed items as having zero main size.
				For the rest of the algorithm following that step,
				ignore the collapsed items entirely
				(as if they were ''display:none'')
				except that after <a href="#algo-cross-line">calculating the cross size of the lines</a>,
				if any line's cross size is less than
				the largest <var>strut size</var>
				among all the collapsed items in the line,
				set its cross size to that <var>strut size</var>.

			<p>
				Skip this step in the second layout round.

		<li id='algo-stretch'>
			<strong>Determine the used cross size of each flex item.</strong>
			If a flex item has ''align-self: stretch'',
			its computed cross size property is <a value for=width>auto</a>,
			and neither of its cross-axis margins are <a value for=margin>auto</a>,
			the used outer cross size is the used cross size of its flex line,
			clamped according to the item's min and max cross size properties.
			Otherwise,
			the used cross size is the item's <i>hypothetical cross size</i>.

			<p class='note'>
				Note that this step does not affect the main size of the flex item,
				even if it has an intrinsic aspect ratio.

			<p class='issue'>
				Proposed text:
				If the flex item has ''align-self: stretch'',
				redo layout for its contents,
				treating this used size as its definite cross size
				so that percentage-sized children can be resolved.
	</ol>

<h3 id='main-alignment'>
Main-Axis Alignment</h3>

	<ol class=continue>
		<li id='algo-main-align'>
			<strong>Distribute any remaining free space.</strong>
			For each flex line:

			<ol>
				<li>
					If the remaining free space is positive
					and at least one main-axis margin on this line is <a value for=margin>auto</a>,
					distribute the free space equally among these margins.
					Otherwise, set all <a value for=margin>auto</a> margins to zero.

				<li>
					Align the items along the main-axis per 'justify-content'.
			</ol>
	</ol>

<h3 id='cross-alignment'>
Cross-Axis Alignment</h3>

	<ol class=continue>
		<li id='algo-cross-margins'>
			<strong>Resolve cross-axis <a value for=margin>auto</a> margins.</strong>
			If a flex item has <a value for=margin>auto</a> cross-axis margins:

			<ul>
				<li>
					If its outer cross size
					(treating those <a value for=margin>auto</a> margins as zero)
					is less than the cross size of its flex line,
					distribute the difference in those sizes equally
					to the <a value for=margin>auto</a> margins.
				<li>
					Otherwise,
					if the <i>block-start</i> or <i>inline-start</i> margin (whichever is in the cross axis)
					is <a value for=margin>auto</a>, set it to zero;
					set the opposite margin so that the outer cross size of the item
					equals the cross size of its flex line.
			</ul>


		<li id='algo-cross-align'>
			<strong>Align all flex items along the cross-axis</strong> per 'align-self',
			if neither of the item's cross-axis margins are <a value for=margin>auto</a>.

		<li id='algo-cross-container'>
			<strong>Determine the flex container's used cross size:</strong>

			<ul>
				<li>
					If the cross size property is a <i>definite</i> size,
					use that,
					clamped by the min and max cross size properties of the <a>flex container</a>.

				<li>
					Otherwise,
					use the sum of the flex lines' cross sizes,
					clamped by the min and max cross size properties of the <a>flex container</a>.
			</ul>

		<li id='algo-line-align'>
			<strong>Align all flex lines</strong> per 'align-content'.
	</ol>

<h3 id='resolve-flexible-lengths'>
Resolving Flexible Lengths</h3>

	<p>
		To resolve the flexible lengths of the items within a flex line:

	<ol>
		<li>
			<strong>Determine the used flex factor.</strong>
			Sum the outer <i>hypothetical main sizes</i> of all items on the line.
			If the sum is less than the flex container's inner main size,
			use the <i>flex grow factor</i> for the rest of this algorithm;
			otherwise, use the <i>flex shrink factor</i>.

		<li>
			<strong>Size inflexible items.</strong>
			For any items that have a flex factor of zero,
			set their used main size
			to their <i>hypothetical main size</i>.

		<li>
			<strong>Check that you can distribute any space.</strong>
			If all the flex items on the line are either frozen
			or have a flex factor of zero,
			exit the algorithm.

		<li>
			<strong>Calculate free space.</strong>
			Sum the outer <i>flex base sizes</i> of all items on the line,
			and subtract this from the flex container's inner main size.
			This is the free space.

		<li>
			<strong>Distribute free space proportional to the flex factors.</strong>
			If the sign of the free space is positive and the algorithm is using the <i>flex grow factor</i>,
			or if the sign of the free space is negative and the algorithm is using the <i>flex shrink factor</i>,
			distribute the free space to each flexible item's main size
			in proportion to the item's flex factor:

			<dl>
				<dt>If the free space is positive</dt>
				<dd>
					Find the ratio of the item's <i>flex grow factor</i>
					to the sum of the <i>flex grow factors</i> of all items on the line.
					Set the item's main size
					to its <i>flex base size</i>
					plus a fraction of the free space
					proportional to the ratio.

				<dt>If the free space is negative</dt>
				<dd>
					For every item on the line,
					multiply its <i>flex shrink factor</i>
					by its outer <i>flex base size</i>,
					and note this as its <dfn>scaled flex shrink factor</dfn>.
					Find the ratio of the item's <i>scaled flex shrink factor</i>
					to the sum of the <i>scaled flex shrink factors</i> of all items on the line.
					Set the item's main size
					to its <i>flex base size</i>
					minus a fraction of the absolute value of the free space
					proportional to the ratio.
					<span class="note">Note this may result in a negative inner main size;
					it will be corrected in the next step.</span>
			</dl>

		<li>
			<strong>Fix min/max violations.</strong>
			Clamp each item's main size by its min and max main size properties.
			If the item's main size was made smaller by this, it's a max violation.
			If the item's main size was made larger by this, it's a min violation.

		<li>
			The total violation is the sum of the adjustments from the previous step
			(<code><var>clamped size</var> - <var>unclamped size</var></code>).
			If the total violation is:

			<dl>
				<dt>Zero
				<dd>
					Exit the algorithm.

				<dt>Positive
				<dd>
					Freeze all the items with min violations,
					reset all other items to their size upon entering this algorithm,
					and return to step 2 of this algorithm.

				<dt>Negative
				<dd>
					Freeze all the items with max violations,
					reset all other items to their size upon entering this algorithm,
					and return to step 2 of this algorithm.
			</dl>
	</ol>

<h3 id='intrinsic-sizes'>
Intrinsic Sizes</h3>

	<p>
		The <dfn>max-content main size</dfn> of a <i>flex container</i>
		is the sum of the flex container's items' <i>max-size contributions</i> in the <i>main axis</i>.
		The <dfn>min-content main size</dfn> of a <i>single-line</i> flex container
		is the sum of the flex container's items' <i>min-size contributions</i> in the <i>main axis</i>;
		for a <i>multi-line</i> container,
		it is the largest of those contributions.

	<p>
		The <dfn>min-content cross size</dfn> and  <dfn>max-content cross size</dfn> of a flex container
		are the cross size of the flex container
		after performing layout into the given available <i>main-axis</i> space and infinite available <i>cross-axis</i> space.

	<p>
		The main-size <i title="min-size contribution">min-content</i>/<i>max-size contribution</i> of a <i>flex item</i>
		is its outer <i>hypothetical main size</i>
		when sized under a <i title="min-size constraint">min-content</i>/<i>max-size constraint</i> (respectively).

	<p>
		See [[!CSS3-SIZING]] for a definition of the terms in this section.

<h2 id="pagination">
Fragmenting Flex Layout</h2>

	<p>
		Flex containers can break across pages
		between items,
		between lines of items (in <i>multi-line</i> mode),
		and inside items.
		The <a property title="break-before">break-*</a> properties apply to flex containers as normal for block-level or inline-level boxes.
		This section defines how they apply to flex items
		and elements inside flex items.

	<p>
		The following breaking rules refer to the fragmentation container as the “page”.
		The same rules apply to any other fragmenters.
		(Substitute “page” with the appropriate fragmenter type as needed.)
		See the CSS3 Fragmentation Module [[!CSS3-BREAK]].
		For readability, in this section the terms "row" and "column" refer to the relative orientation
		of the flex container with respect to the block flow direction of the fragmentation context,
		rather than to that of the flex container itself.

	<p>
		The exact layout of a fragmented flex container is not defined in this level of Flexible Box Layout.
		However, breaks inside a flex container are subject to the following rules:

	<ul>
		<li>
			In a row flex container,
			the 'break-before' and 'break-after' properties on flex items
			are propagated to the flex line.
			The 'break-before' property on the first line
			and the 'break-after' property on the last line
			are propagated to the flex container.

		<li>
			In a column flex container,
			the 'break-before' property on the first item
			and the 'break-after' property on the last item
			are propagated to the flex container.
			Forced breaks on other items are applied to the item itself.

		<li>
			A forced break inside a flex item effectively increases the size of its contents;
			it does not trigger a forced break inside sibling items.

		<li>
			In a row flex container,
			<a href="http://www.w3.org/TR/css3-break/#btw-blocks">Class A break opportunities</a> occur between sibling flex lines,
			and <a href="http://www.w3.org/TR/css3-break/#end-block">Class C break opportunities</a> occur between the first/last flex line and the flex container's content edges.
			In a column flex container,
			<a href="http://www.w3.org/TR/css3-break/#btw-blocks">Class A break opportunities</a> occur between sibling flex items,
			and <a href="http://www.w3.org/TR/css3-break/#end-block">Class C break opportunities</a> occur between the first/last flex items on a line and the flex container's content edges.
			[[!CSS3-BREAK]]

		<li>
			When a flex container is continued after a break,
			the space available to its <i>flex items</i>
			(in the block flow direction of the fragmentation context)
			is reduced by the space consumed by flex container fragments on previous pages.
			The space consumed by a flex container fragment is
			the size of its content box on that page.
			If as a result of this adjustment the available space becomes negative,
			it is set to zero.

		<li>
			If the first fragment of the flex container is not at the top of the page,
			and some of its flex items don't fit in the remaining space on the page,
			the entire fragment is moved to the next page.

		<li>
			When a <i>multi-line</i> colum flex container breaks,
			each fragment has its own "stack" of flex lines,
			just like each fragment of a multi-column element
			has its own row of column boxes.

		<li>
			Aside from the rearrangement of items imposed by the previous point,
			UAs should attempt to minimize distortation of the flex container
			with respect to unfragmented flow.
	</ul>


<h3 id='pagination-algo'>
Sample Flex Fragmentation Algorithm</h3>

	<p>
		This informative section presents a possible fragmentation algorithm for flex containers.
		Implementors are encouraged to improve on this algorithm and <a href='#status'>provide feedback to the CSS Working Group</a>.

<div class='example'>

	<p class='note'>
		This algorithm assumes that pagination always proceeds only in the forward direction;
		therefore, in the algorithms below, alignment is mostly ignored prior to pagination.
		Advanced layout engines may be able to honor alignment across fragments.

	<dl>
		<dt><i>Single-line</i> column flex container
		<dd>
			<ol>
				<li>
					Run the flex layout algorithm (without regards to pagination)
					through <a href="#cross-sizing">Cross Sizing Determination</a>.

				<li>
					Lay out as many consecutive flex items or item fragments as possible
					(but at least one or a fragment thereof),
					starting from the first,
					until there is no more room on the page
					or a forced break is encountered.

				<li>
					If the previous step ran out of room
					and the free space is positive,
					the UA may reduce the distributed free space on this page
					(down to, but not past, zero)
					in order to make room for the next unbreakable flex item or fragment.
					Otherwise,
					the item or fragment that does not fit is pushed to the next page.
					The UA should pull up if more than 50% of the fragment would have fit in the remaining space
					and should push otherwise.

				<li>
					If there are any flex items or fragments not laid out by the previous steps,
					rerun the flex layout algorithm
					from <a href="#line-sizing">Line Length Determination</a>
					through <a href="#cross-sizing">Cross Sizing Determination</a>
					with the next page's size
					and <em>all</em> the contents (including those already laid out),
					and return to the previous step,
					but starting from the first item or fragment not already laid out.

				<li>
					For each fragment of the flex container,
					continue the flex layout algorithm
					from <a href="#main-alignment">Main-Axis Alignment</a>
					to its finish.
			</ol>

			<p class="note">
				It is the intent of this algorithm that column-direction <i>single-line</i> flex containers
				paginate very similarly to block flow.
				As a test of the intent,
				a flex container with ''justify-content:start''
				and no flexible items
				should paginate identically to
				a block with in-flow children with same content,
				same used size and same used margins.

		<dt><i>Multi-line</i> column flex container
		<dd>
			<ol>
				<li>
					Run the flex layout algorithm
					<em>with</em> regards to pagination
					(limiting the flex container's maximum line length to the space left on the page)
					through <a href="#cross-sizing">Cross Sizing Determination</a>.

				<li>
					Lay out as many flex lines as possible
					(but at least one)
					until there is no more room in the flex container
					in the cross dimension
					or a forced break is encountered:

					<ol>
						<li>
							Lay out as many consecutive flex items as possible
							(but at least one),
							starting from the first,
							until there is no more room on the page
							or a forced break is encountered.
							Forced breaks <em>within</em> flex items are ignored.

						<li>
							If this is the first flex container fragment,
							this line contains only a single flex item
							that is larger than the space left on the page,
							and the flex container is not at the top of the page already,
							move the flex container to the next page
							and restart flex container layout entirely.

						<li>
							If there are any flex items not laid out by the first step,
							rerun the flex layout algorithm
							from <a href="#main-sizing">Main Sizing Determination</a>
							through <a href="#cross-sizing">Cross Sizing Determination</a>
							using only the items not laid out on a previous line,
							and return to the previous step,
							starting from the first item not already laid out.
					</ol>

				<li>
					If there are any flex items not laid out by the previous step,
					rerun the flex layout algorithm
					from <a href="#line-sizing">Line Sizing Determination</a>
					through <a href="#cross-sizing">Cross Sizing Determination</a>
					with the next page's size
					and only the items not already laid out,
					and return to the previous step,
					but starting from the first item not already laid out.

				<li>
					For each fragment of the flex container,
					continue the flex layout algorithm
					from <a href="#main-alignment">Main-Axis Alignment</a>
					to its finish.
			</ol>

			<p class='note'>
				If a flex item does not entirely fit on a single page,
				it will <em>not</em> be paginated in <i>multi-line</i> column flex containers.

		<dt><i>Single-line</i> row flex container
		<dd>
			<ol>
				<li>
					Run the entire flex layout algorithm (without regards to pagination),
					except treat any 'align-self' other than ''start'' or ''baseline'' as ''start''.

				<li>
					If an unbreakable item doesn't fit within the space left on the page,
					and the flex container is not at the top of the page,
					move the flex container to the next page
					and restart flex container layout entirely.

				<li>
					For each item,
					lay out as much of its contents as will fit in the space left on the page,
					and fragment the remaining content onto the next page,
					rerunning the flex layout algorithm
					from <a href="#line-sizing">Line Length Determination</a>
					through <a href="#main-alignment">Main-Axis Alignment</a>
					into the new page size
					using <em>all</em> the contents (including items completed on previous pages).

					<p class='note'>
						Any flex items that fit entirely into previous fragments
						still take up space in the main axis in later fragments.

				<li>
					For each fragment of the flex container,
					rerun the flex layout algorithm
					from <a href="#cross-alignment">Cross-Axis Alignment</a>
					to its finish.
					For all fragments besides the first,
					treat 'align-self' and 'align-content' as being ''start'' for all item fragments and lines.

				<li>
					If any item,
					when aligned according to its original 'align-self' value
					into the combined cross size of all the flex container fragments,
					would fit entirely within a single flex container fragment,
					it may be shifted into that fragment
					and aligned appropriately.
			</ol>

		<dt><i>Multi-line</i> row flex container
		<dd>
			<ol>
				<li>
					Run the flex layout algorithm (without regards to pagination),
					through <a href="#cross-sizing">Cross Sizing Determination</a>.

				<li>
					Lay out as many flex lines as possible
					(but at least one),
					starting from the first,
					until there is no more room on the page
					or a forced break is encountered.

					<p>
						If a line doesn't fit on the page,
						and the line is not at the top of the page,
						move the line to the next page
						and restart the flex layout algorithm entirely,
						using only the items in and following this line.

					<p>
						If a flex item itself causes a forced break,
						rerun the flex layout algorithm
						from <a href="#main-sizing">Main Sizing Determination</a>
						through <a href="#main-alignment">Main-Axis Alignment</a>,
						using only the items on this and following lines,
						but with the item causing the break automatically starting a new line
						in the <a href="#algo-line-break">line breaking step</a>,
						then continue with this step.
						Forced breaks <em>within</em> flex items are ignored.

				<li>
					If there are any flex items not laid out by the previous step,
					rerun the flex layout algorithm
					from <a href="#line-sizing">Line Length Determination</a>
					through <a href="#main-alignment">Main-Axis Alignment</a>
					with the next page's size
					and only the items not already laid out.
					Return to the previous step,
					but starting from the first line not already laid out.

				<li>
					For each fragment of the flex container,
					continue the flex layout algorithm
					from <a href="#cross-alignment">Cross Axis Alignment</a>
					to its finish.
			</ol>
	</dl>
</div>


<h2 class="no-num" id="acknowledgments">Acknowledgments</h2>

	<p>Thanks for feedback and contributions to

Erik Anderson,
Tony Chang,
Phil Cupp,
Arron Eicholz,
James Elmore,
Andrew Fedoniouk,
Brian Heuston,
Shinichiro Hamaji,
Daniel Holbert,
Ben Horst,
John Jansen,
Brad Kemper,
Kang-hao Lu,
Markus Mielke,
Robert O'Callahan,
Christoph Päper,
Ning Rogers,
Peter Salas,
Morten Stenshorne,
Christian Stockwell,
Ojan Vafai,
Eugene Veselov,
Boris Zbarsky.

<h2 class="no-num" id="changes">Changes</h2>

	<p>
		The following significant changes were made since the
		<a href="http://www.w3.org/TR/2012/CR-css3-flexbox-20120918/">18 September 2012 Candidate Recommendation</a>:
	<ul>
		<li>
			Reverted the initial value of 'min-width'/'min-height' back to being ''0'' (not <a value for=width>auto</a>).
		<li>
			Specified that percentage margins/paddings on flex items are resolved against their respective dimensions,
			not the inline dimension of the containing block like blocks do.
		<li>
			<a href="#algo-main-item">Allow intrinsic aspect ratios to inform the main-size calculation.</a>
		<li>
			<a href="#intrinsic-sizes">Defined the intrinsic sizes of flex containers.</a>
		<li>
			Correct an omission in the flex-line size determination, so a <i>single-line</i> flexbox will size to its contents if it doesn't have a definite size.
		<li>
			Flex lines have their size floored at 0.
		<li>
			Flex items paint like inline blocks rather than blocks.
		<li>
			An omitted 'flex-basis' component of the 'flex' shorthand now resolves to ''0%'' instead of ''0px''.
		<li>
			Defined that an unresolvable percentage <i>flex base size</i> is treated as <a value for=width>auto</a>.
		<li>
			Simplified the static position of abspos children of <a>flex containers</a> to be consistent with Grid Layout.
	</ul>

	<p>The following significant clarifications were also made:
	<ul>
		<li>
			Absolutely positioned children of a flex container are no longer called "flex items" (to avoid terminology confusion).
		<li>
			Clarified that 'float' still makes the children of a flex container turn into block-level elements.
		<li>
			Clarified that table anonymous box generation occurs in place of computed value conversion for internal table elements.
		<li>
			Clarified that 'overflow' applies to flex containers.
		<li>
			Clarified that ''::first-line'' and ''::first-letter'' pseudo-elements do not apply to flex containers (because they are not block containers).
		<li>
			Clarify that <a value for=align-self>stretch</a> checks for the <em>computed</em> value of the cross-size property being <a value for=width>auto</a>,
			which means that percentage cross-sizes that behave as <a value for=width>auto</a>
			(because they don't resolve against definite sizes) aren't stretched.
		<li>
			Clarified that 'order'-modified document order is used instead of raw document order when painting.
			(This was already stated in the 'order' section, but not in the section explicitly about painting order.)
		<li>
			Clarified where zero-main-size flex items go when they're at the end of a line.
		<li>
			Clarified that flex container cross sizes are still clamped by the flex container's min/max properties.
	</ul>

	<p>A <a href="http://dev.w3.org/csswg/css3-flexbox/issues-cr-2012">Disposition of Candidate Recommendation Comments</a> is available.
